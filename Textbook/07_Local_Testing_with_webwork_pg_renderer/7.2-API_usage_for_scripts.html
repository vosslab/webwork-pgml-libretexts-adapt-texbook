<p>
This page explains how to call the webwork-pg-renderer API from scripts for programmatic rendering,
linting, and automated testing. Use this when you need to render problems from Python, shell
scripts, or CI/CD pipelines instead of the browser editor.
</p>

<p>
<strong>Use this page when:</strong> you are building automation scripts, batch-linting problem
files, or integrating rendering into a workflow.
</p>

<h2>API endpoints</h2>
<p>
The renderer exposes three HTTP endpoints:
</p>

<h3>POST / (primary, modern)</h3>
<p>
Use this endpoint for all new scripts. Accepts both <code>application/json</code> and
<code>application/x-www-form-urlencoded</code> content types. Supports all input modes and format
options.
</p>
<pre>
POST http://localhost:3000/
</pre>

<h3>POST /render-api (compatibility, legacy)</h3>
<p>
Legacy endpoint for backwards compatibility with older WeBWorK integration code. Behaves identically
to <code>POST /</code> but may be deprecated in future versions. Prefer <code>POST /</code> for new
work.
</p>
<pre>
POST http://localhost:3000/render-api
</pre>

<h3>GET /health (status check)</h3>
<p>
Returns a simple JSON status response. Use this to verify that the renderer is running and
accepting requests before attempting to render problems.
</p>
<pre>
curl http://localhost:3000/health
# Returns: {"status":"ok"}
</pre>

<h2>Parameter precedence (source input types)</h2>
<p>
The renderer accepts three different ways to specify the problem source. If you provide multiple
inputs in one request, the renderer uses the highest-precedence source and ignores the rest.
</p>

<p>
<strong>Precedence order:</strong> <code>problemSourceURL</code> &gt; <code>problemSource</code> &gt; <code>sourceFilePath</code>
</p>

<h3>problemSourceURL (highest precedence)</h3>
<p>
<strong>What it is:</strong> A URL pointing to a JSON endpoint that returns the problem source in a
<code>raw_source</code> field.
</p>
<p>
<strong>Use when:</strong> Problem source lives on a remote server (e.g., ADAPT API, GitHub raw URL).
</p>
<p>
<strong>Example:</strong>
</p>
<pre>
{
  "problemSourceURL": "https://example.com/problems/123.json",
  "problemSeed": 1234
}
</pre>
<p>
The renderer will fetch the URL and expect a JSON response like:
</p>
<pre>
{
  "raw_source": "## DESCRIPTION\n...",
  "other_metadata": "..."
}
</pre>

<h3>problemSource (middle precedence)</h3>
<p>
<strong>What it is:</strong> Raw PG source code as a string. Can be plain text or base64-encoded.
</p>
<p>
<strong>Use when:</strong> Source is generated in memory, script-generated, or filesystem is
unavailable. This is the most common mode for scripting and automation.
</p>
<p>
<strong>Example:</strong>
</p>
<pre>
{
  "problemSource": "## DESCRIPTION\nCalculate dilution factor.\n## ENDDESCRIPTION\n...",
  "problemSeed": 1234
}
</pre>
<p>
<strong>Encoding:</strong> If your PG source contains characters that are hard to embed in JSON
(e.g., nested quotes), you can base64-encode it and set <code>"sourceEncoding": "base64"</code>.
</p>

<h3>sourceFilePath (lowest precedence)</h3>
<p>
<strong>What it is:</strong> Path to a <code>.pg</code> file relative to the renderer's
<code>Library/</code>, <code>Contrib/</code>, or <code>private/</code> directories.
</p>
<p>
<strong>Use when:</strong> File exists in the renderer container's filesystem. Ideal for local
development and testing when you have direct access to the file.
</p>
<p>
<strong>Example:</strong>
</p>
<pre>
{
  "sourceFilePath": "private/myproblem.pg",
  "problemSeed": 1234
}
</pre>
<p>
<strong>Note:</strong> If the file is outside the container (e.g., on your host machine but not
volume-mounted into <code>private/</code>), use <code>problemSource</code> instead and read the
file in your script before sending.
</p>

<h2>Complete curl examples</h2>

<h3>Example 1: Render with sourceFilePath (form-encoded)</h3>
<p>
Use form-encoded mode (<code>-F</code> flags) when calling from shell scripts. This is the simplest
approach for quick testing.
</p>
<pre>
curl -X POST "http://localhost:3000/" \
  -F "sourceFilePath=private/dilution.pg" \
  -F "problemSeed=1234" \
  -F "problemLang=en" \
  -F "displayMode=MathJax" \
  -F "_format=json"
</pre>
<p>
<strong>Output:</strong> JSON response with <code>renderedHTML</code>, <code>flags</code>, and
<code>debug</code> fields.
</p>

<h3>Example 2: Render with problemSource (JSON)</h3>
<p>
Use JSON mode when calling from scripts with complex source or when you need precise control over
parameters. This is the preferred mode for Python/Node.js scripts.
</p>
<pre>
curl -X POST "http://localhost:3000/" \
  -H "Content-Type: application/json" \
  -d '{
    "problemSource": "## DESCRIPTION\nCalculate dilution factor.\n## ENDDESCRIPTION\nDOCUMENT();\nloadMacros(\"PGstandard.pl\",\"PGML.pl\",\"PGcourse.pl\");\nTEXT(beginproblem());\n\nBEGIN_PGML\nTest problem.\nEND_PGML\nENDDOCUMENT();",
    "problemSeed": 1234,
    "_format": "json"
  }'
</pre>
<p>
<strong>Tip:</strong> In real scripts, read the PG source from a file and construct the JSON
payload programmatically instead of embedding it in the curl command.
</p>

<h3>Example 3: Get HTML output directly</h3>
<p>
Omit <code>_format</code> or set <code>_format: html</code> to get the rendered HTML page directly
(not wrapped in JSON). Useful for visual inspection.
</p>
<pre>
curl -X POST "http://localhost:3000/" \
  -H "Content-Type: application/json" \
  -d '{
    "sourceFilePath": "private/enzyme_kinetics.pg",
    "problemSeed": 5678,
    "_format": "html"
  }' &gt; output.html

# Open output.html in a browser to see the rendered problem
</pre>

<h3>Example 4: Enable instructor mode</h3>
<p>
Set <code>isInstructor: 1</code> to unlock instructor-only fields in the JSON response, including
correct answers and answer evaluator details.
</p>
<pre>
curl -X POST "http://localhost:3000/" \
  -H "Content-Type: application/json" \
  -d '{
    "sourceFilePath": "private/dilution.pg",
    "problemSeed": 1234,
    "_format": "json",
    "isInstructor": 1
  }'
</pre>
<p>
<strong>Instructor fields:</strong> <code>answers</code> (with correct values), <code>debug</code>
(with internal state), and additional metadata useful for problem review.
</p>

<h2>Python example: Batch rendering</h2>
<p>
Use the <code>requests</code> library to render problems from Python scripts. This is ideal for
automation, linting, and batch processing.
</p>

<h3>Basic rendering function</h3>
<pre>
import requests

def render_pg_file(filepath, seed=1234):
    """
    Render a .pg file and return the JSON response.
    """
    # Read the problem source
    with open(filepath, 'r') as f:
        pg_source = f.read()

    # Render via API
    response = requests.post(
        'http://localhost:3000/',
        json={
            'problemSource': pg_source,
            'problemSeed': seed,
            '_format': 'json',
            'isInstructor': 1,
        }
    )

    return response.json()

# Example usage
data = render_pg_file('problems/dilution_factor.pg', seed=1000)
if data.get('flags', {}).get('error_flag'):
    print('Render error!')
    print(data.get('debug', {}).get('pg_warn', []))
else:
    print('Success!')
    print(data['renderedHTML'][:200])  # Preview first 200 chars
</pre>

<h3>Extracting lint warnings</h3>
<p>
The JSON response includes a <code>debug.pg_warn</code> array with warning messages from the
renderer. Use this to build lint tools.
</p>
<pre>
def get_warnings(data):
    """
    Extract warning messages from a render response.
    """
    warnings = data.get('debug', {}).get('pg_warn', [])
    error_flag = data.get('flags', {}).get('error_flag', 0)

    return {
        'has_errors': bool(error_flag),
        'warnings': warnings,
    }

# Example usage
data = render_pg_file('problems/my_problem.pg')
result = get_warnings(data)
if result['has_errors'] or result['warnings']:
    print(f"Issues found: {result['warnings']}")
</pre>

<h2>Lint workflow: Batch checking multiple files</h2>
<p>
Use this pattern to lint all <code>.pg</code> files in a directory tree. This is useful for CI/CD
pipelines and pre-commit hooks.
</p>

<pre>
import os
import requests

def lint_pg_file(filepath, seed=1000):
    """
    Lint a single .pg file and return pass/fail status.
    """
    with open(filepath) as f:
        source = f.read()

    resp = requests.post('http://localhost:3000/', json={
        'problemSource': source,
        'problemSeed': seed,
        '_format': 'json',
    })

    data = resp.json()
    warnings = data.get('debug', {}).get('pg_warn', [])
    error_flag = data.get('flags', {}).get('error_flag', 0)

    if error_flag or warnings:
        print(f'{filepath}: FAIL')
        for w in warnings:
            print(f'  {w}')
        return False
    else:
        print(f'{filepath}: OK')
        return True

# Lint all .pg files in a directory tree
failed_files = []
for root, dirs, files in os.walk('problems/'):
    for f in files:
        if f.endswith('.pg'):
            fpath = os.path.join(root, f)
            if not lint_pg_file(fpath):
                failed_files.append(fpath)

if failed_files:
    print(f"\n{len(failed_files)} files failed lint")
    exit(1)
else:
    print(f"\nAll files passed lint")
    exit(0)
</pre>

<h2>Response format: JSON structure</h2>
<p>
When <code>_format: json</code> is set, the renderer returns a structured JSON response. Here are
the key fields:
</p>

<h3>Common response fields</h3>
<table class="mt-responsive-table">
	<colgroup>
		<col style="width: 28%;">
		<col style="width: 18%;">
		<col style="width: 54%;">
	</colgroup>
	<thead>
		<tr>
			<th>Field</th>
			<th>Type</th>
			<th>Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td data-th="Field">renderedHTML</td>
			<td data-th="Type">string</td>
			<td data-th="Description">The rendered problem HTML (student view)</td>
		</tr>
		<tr>
			<td data-th="Field">flags.error_flag</td>
			<td data-th="Type">int</td>
			<td data-th="Description">0 = success, 1 = rendering error</td>
		</tr>
		<tr>
			<td data-th="Field">debug.pg_warn</td>
			<td data-th="Type">array</td>
			<td data-th="Description">Array of warning messages from the renderer</td>
		</tr>
		<tr>
			<td data-th="Field">answers</td>
			<td data-th="Type">object</td>
			<td data-th="Description">(Instructor-only) Answer structure with correct values and evaluators</td>
		</tr>
		<tr>
			<td data-th="Field">problem_seed</td>
			<td data-th="Type">int</td>
			<td data-th="Description">The seed used for this render (echo of input)</td>
		</tr>
	</tbody>
</table>

<h3>Checking for success</h3>
<p>
A successful render has <code>flags.error_flag == 0</code> and an empty or absent
<code>debug.pg_warn</code> array. Always check both fields:
</p>
<pre>
error_flag = data.get('flags', {}).get('error_flag', 0)
warnings = data.get('debug', {}).get('pg_warn', [])

if error_flag:
    print("Rendering failed completely")
elif warnings:
    print("Rendering succeeded with warnings:")
    for w in warnings:
        print(f"  - {w}")
else:
    print("Clean render, no issues")
</pre>

<h3>HTML format (not JSON)</h3>
<p>
When <code>_format: html</code> is set (or omitted), the renderer returns a full HTML page
directly. Use this for visual inspection in a browser but not for automated processing.
</p>

<h2>Common use cases</h2>

<h3>Use case 1: CI/CD lint check</h3>
<p>
In a GitHub Actions or GitLab CI pipeline, use the Python lint workflow to fail the build if any
<code>.pg</code> file has rendering errors.
</p>
<pre>
# .github/workflows/lint.yml
steps:
  - name: Start renderer
    run: docker compose up -d

  - name: Lint all problems
    run: python scripts/lint_all_pg.py
</pre>

<h3>Use case 2: Generate problem previews</h3>
<p>
Render each problem with multiple seeds and save the HTML output for manual review or documentation.
</p>
<pre>
for seed in [1000, 2000, 3000]:
    data = render_pg_file('problem.pg', seed=seed)
    with open(f'preview_seed_{seed}.html', 'w') as f:
        f.write(data['renderedHTML'])
</pre>

<h3>Use case 3: Regression testing</h3>
<p>
Compare rendered HTML from a known-good version to detect unintended changes when updating macros
or the renderer.
</p>

<h2>Cross-references</h2>
<ul>
	<li><strong>Chapter 7.1:</strong> Manual testing workflow with browser editor (use before automation)</li>
	<li><strong>Chapter 2.5:</strong> Macro availability reference (check before copying online examples)</li>
	<li><strong>Chapter 6.5:</strong> Using problemSeed for reproducible randomization</li>
</ul>

<h2>Apply it today</h2>
<ul>
	<li>Use <code>GET /health</code> to verify the renderer is running before sending requests.</li>
	<li>Use <code>sourceFilePath</code> for local development, <code>problemSource</code> for scripts.</li>
	<li>Always set <code>_format: json</code> when linting or processing results programmatically.</li>
	<li>Use fixed seeds in lint scripts to make failures reproducible.</li>
	<li>Check both <code>flags.error_flag</code> and <code>debug.pg_warn</code> for complete status.</li>
	<li>Build lint workflows that run in CI/CD to catch rendering errors before deployment.</li>
</ul>
