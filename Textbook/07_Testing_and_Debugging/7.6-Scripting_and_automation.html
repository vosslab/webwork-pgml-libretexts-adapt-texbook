<p>
Use this section when you need to render or lint problems programmatically rather than through the
browser editor. This covers the renderer API endpoints, scripting examples, and batch linting
workflows. This section is for advanced users who are comfortable with command-line tools and
scripting. The examples below assume the renderer is already running on
<code>http://localhost:3000</code> (see <a href="/@go/page/555732">Section 7.1</a> for setup).
</p>

<h2>API endpoints</h2>
<p>
The renderer exposes three HTTP endpoints. Use the primary endpoint for all new scripts.
</p>
<table class="mt-responsive-table">
	<thead>
		<tr>
			<th>Endpoint</th>
			<th>Method</th>
			<th>Use for</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td data-th="Endpoint"><code>/</code></td>
			<td data-th="Method">POST</td>
			<td data-th="Use for">Primary endpoint for rendering problems (preferred for all new work)</td>
		</tr>
		<tr>
			<td data-th="Endpoint"><code>/render-api</code></td>
			<td data-th="Method">POST</td>
			<td data-th="Use for">Legacy compatibility endpoint (same behavior as <code>/</code>)</td>
		</tr>
		<tr>
			<td data-th="Endpoint"><code>/health</code></td>
			<td data-th="Method">GET</td>
			<td data-th="Use for">Check if the renderer is running and accepting requests</td>
		</tr>
	</tbody>
</table>

<h2>Parameter precedence</h2>
<p>
The renderer accepts three input types for specifying problem source. If you provide more than one,
the renderer uses the highest-precedence source and ignores the rest.
</p>
<p>
<strong>Precedence order:</strong> <code>problemSourceURL</code> (highest) &gt;
<code>problemSource</code> (middle) &gt; <code>sourceFilePath</code> (lowest)
</p>
<table class="mt-responsive-table">
	<thead>
		<tr>
			<th>Parameter</th>
			<th>What it is</th>
			<th>Use when</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td data-th="Parameter"><code>problemSourceURL</code></td>
			<td data-th="What it is">URL to a JSON endpoint that returns problem source</td>
			<td data-th="Use when">Problem source lives on a remote server</td>
		</tr>
		<tr>
			<td data-th="Parameter"><code>problemSource</code></td>
			<td data-th="What it is">Raw PG source as a string</td>
			<td data-th="Use when">Source is generated by a script or read from a file (most common for automation)</td>
		</tr>
		<tr>
			<td data-th="Parameter"><code>sourceFilePath</code></td>
			<td data-th="What it is">Path relative to the renderer's <code>private/</code> or <code>Library/</code> directory</td>
			<td data-th="Use when">File exists inside the renderer container</td>
		</tr>
	</tbody>
</table>

<h2>Curl example</h2>
<p>
The simplest way to test the renderer from the command line is a form-encoded POST with
<code>curl</code>:
</p>
<pre>
curl -X POST "http://localhost:3000/" \
  -F "sourceFilePath=private/myproblem.pg" \
  -F "problemSeed=1234" \
  -F "_format=json"
</pre>
<ul>
	<li><code>sourceFilePath</code> -- path relative to the renderer's directory structure.</li>
	<li><code>problemSeed</code> -- integer seed for randomization. Use a fixed seed so failures are reproducible.</li>
	<li><code>_format=json</code> -- returns structured JSON instead of HTML. Always use this for scripted workflows.</li>
</ul>
<p>
If the file is on your host machine but not mounted into the container, read it in your script and
send it as <code>problemSource</code> instead.
</p>

<h2>Python example</h2>
<p>
This function reads a local <code>.pg</code> file, sends it to the renderer, and reports problems:
</p>
<pre>
import requests

def render_pg_file(filepath, seed=1234):
    with open(filepath, 'r') as f:
        pg_source = f.read()
    response = requests.post(
        'http://localhost:3000/',
        json={
            'problemSource': pg_source,
            'problemSeed': seed,
            '_format': 'json',
        }
    )
    data = response.json()
    error_flag = data.get('flags', {}).get('error_flag', 0)
    warnings = data.get('debug', {}).get('pg_warn', [])
    if error_flag:
        print(f'Error rendering {filepath}')
    elif warnings:
        print(f'Warnings for {filepath}:')
        for w in warnings:
            print(f'  {w}')
    else:
        print(f'{filepath}: OK')
    return data
</pre>
<p>
Call <code>render_pg_file('problems/my_problem.pg')</code> to test a single file. The function
returns the full JSON response so you can inspect <code>renderedHTML</code>, <code>answers</code>, or
other fields as needed.
</p>

<h2>Batch linting</h2>
<p>
To lint all <code>.pg</code> files in a directory tree, walk the directory and render each file:
</p>
<pre>
import os

failed = []
for root, dirs, files in os.walk('problems/'):
    for f in files:
        if f.endswith('.pg'):
            path = os.path.join(root, f)
            data = render_pg_file(path)
            if data.get('flags', {}).get('error_flag'):
                failed.append(path)

if failed:
    print(f'{len(failed)} files failed')
else:
    print('All files passed')
</pre>
<p>
Use a fixed seed so that any failure you find is reproducible.
</p>

<h2>Response format</h2>
<p>
When <code>_format=json</code> is set, the renderer returns a structured JSON object. Key fields:
</p>
<table class="mt-responsive-table">
	<thead>
		<tr>
			<th>Field</th>
			<th>Type</th>
			<th>Description</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td data-th="Field"><code>renderedHTML</code></td>
			<td data-th="Type">string</td>
			<td data-th="Description">The rendered problem HTML (student view)</td>
		</tr>
		<tr>
			<td data-th="Field"><code>flags.error_flag</code></td>
			<td data-th="Type">int</td>
			<td data-th="Description">0 = success, 1 = rendering error</td>
		</tr>
		<tr>
			<td data-th="Field"><code>debug.pg_warn</code></td>
			<td data-th="Type">array</td>
			<td data-th="Description">Warning messages from the renderer</td>
		</tr>
		<tr>
			<td data-th="Field"><code>answers</code></td>
			<td data-th="Type">object</td>
			<td data-th="Description">(Instructor mode) Answer structure with correct values</td>
		</tr>
	</tbody>
</table>

<h2>Checking for success</h2>
<p>
A clean render has <code>error_flag == 0</code> and an empty <code>pg_warn</code> array. Always
check both, because a problem can render without a fatal error but still produce warnings:
</p>
<pre>
error_flag = data.get('flags', {}).get('error_flag', 0)
warnings = data.get('debug', {}).get('pg_warn', [])

if error_flag:
    print('Rendering failed completely')
elif warnings:
    print('Rendered with warnings:')
    for w in warnings:
        print(f'  - {w}')
else:
    print('Clean render, no issues')
</pre>

<h2>Apply it today</h2>
<ul>
	<li>Start with the curl example above to verify your renderer is responding.</li>
	<li>Adapt the Python <code>render_pg_file</code> function for your own workflow.</li>
	<li>Use the batch linting pattern to check an entire directory of problems before publishing.</li>
	<li>Always set <code>_format=json</code> and check both <code>flags.error_flag</code> and <code>debug.pg_warn</code> in scripted workflows.</li>
</ul>
