<p>
This page covers modern matching problems using PopUp widgets and two-column layouts. It also
explains the one case where <code>MODES(HTML =&gt; ...)</code> is required: wrapper HTML that must be
emitted from inside Perl eval blocks that build dynamic HTML with <code>join()</code>.
</p>

<p>
<strong>Use this page when:</strong> you need a two-column matching layout with consistent labels
and randomized ordering. For basic matching with PopUp dropdowns, see
<a href="/@go/page/555717">Matching</a>.
</p>

<h2>When to use matching vs other question types</h2>
<p>
Matching problems work best for:
</p>
<ul>
	<li><strong>Definitions:</strong> Match terms with their meanings (e.g., genotype vs phenotype)</li>
	<li><strong>Associations:</strong> Connect related concepts (e.g., enzyme names with their substrates)</li>
	<li><strong>Component identification:</strong> Link structures to functions (e.g., organelles to their roles)</li>
	<li><strong>Classification:</strong> Match examples to categories (e.g., bond types to molecular scenarios)</li>
</ul>

<h4>Not ideal for</h4>
<ul>
	<li>Pure memorization with no conceptual pairing</li>
	<li>Sequence ordering (use drag-and-drop or ordered list instead)</li>
	<li>True/false evaluation of statements (use RadioButtons per statement, see <a href="/@go/page/555726">Randomized MC True and False Statements</a>)</li>
</ul>

<p>
<strong>Typical problem sizes:</strong> 4-8 pairs work well. Fewer than 4 is too easy; more than 8
becomes cognitively overwhelming and increases guessing.
</p>

<h2>PopUp widgets for matching</h2>
<p>
Use <code>PopUp</code> widgets from <code>parserPopUp.pl</code> to create dropdown menus in the left
column. Note that <code>DropDown</code> is a PG 2.18+ macro and is not available in the PG 2.17
subset used by ADAPT/renderer.
</p>

<h3>Widget creation pattern</h3>
<pre>
loadMacros(
  "PGstandard.pl",
  "PGML.pl",
  "parserPopUp.pl",
  "PGcourse.pl",
);

# Define choices (labels A, B, C, D for 4 answers)
my @choices = ('A', 'B', 'C', 'D');

# Define correct answers (mapped to choices)
my @correct_answers = ('B', 'D', 'A', 'C');  # Correct letter for each question

# Create PopUp widgets
my @answer_dropdowns = map { PopUp(\@choices, $correct_answers[$_]) } 0 .. $#correct_answers;
</pre>

<h3>How shuffle arrays work</h3>
<p>
Use the <code>shuffle()</code> function to randomize the order of right-column answers while
maintaining correct left-right mapping:
</p>
<pre>
my @questions = (
  'Two oxygen atoms share electrons equally',
  'Sodium transfers an electron to chlorine',
  'Partial charges on C-O bond',
  'O-H bond attracted to nearby C=O',
);

my @answers = (
  'non-polar covalent bond',
  'ionic bond',
  'polar covalent bond',
  'hydrogen bond',
);

# Shuffle the right column
my @shuffle = shuffle(scalar(@answers));  # Returns a permutation [0..3]

# Now answers appear in shuffled order, but @shuffle maps them back to originals
</pre>

<h3>Answer evaluation in PGML</h3>
<p>
In the left column, use <code>[_]{$answer_dropdowns[$i]}</code> to insert each PopUp widget. The
student selects a letter from the dropdown, and WeBWorK checks it against the correct answer stored
in the widget.
</p>

<h2>Two layout patterns: When MODES is needed</h2>
<p>
There are two ways to build matching layouts: with wrapper tags directly in PGML (preferred), or
with <code>MODES</code> when wrapper HTML must be emitted from inside Perl eval blocks.
</p>

<h3>Pattern 1: Wrapper tags directly in PGML (preferred)</h3>
<p>
If you can write the wrapper <code>&lt;div&gt;</code> tags directly in PGML, do that. This avoids
<code>MODES</code> entirely and is easier to read and maintain.
</p>
<pre>
BEGIN_PGML
Match each molecular scenario with its bond type.

&lt;div class="two-column"&gt;
&lt;div&gt;
[@ join("\n\n", map {
  '[_]{$answer_dropdowns[' . $_ . ']} '
    . '*' . ($_ + 1) . '.* '
    . $questions[$_]
} 0 .. $#questions) @]**
&lt;/div&gt;

&lt;div&gt;
[@ join("\n\n", map {
  '*' . chr(65 + $_) . '.* '
    . $answers[$shuffle[$_]]
} 0 .. $#answers) @]**
&lt;/div&gt;
&lt;/div&gt;
END_PGML
</pre>
<p>
In this pattern, the <code>&lt;div class="two-column"&gt;</code> wrapper is written directly in PGML.
The <code>join()</code> expressions build the content for each column, and PGML processes everything
correctly without needing <code>MODES</code>.
</p>

<h3>Pattern 2: MODES when wrapper must be in eval block (required in specific cases)</h3>
<p>
Use <code>MODES(HTML =&gt; ...)</code> only when the wrapper tags must be built inside a Perl eval
block, such as when the wrapper and content are created together in a single Perl variable. Without
<code>MODES</code>, the wrapper HTML gets escaped by PGML and the layout collapses to a single column.
</p>
<pre>
# Build left column HTML
my $left_html = join("\n\n", map {
  '[_]{$answer_dropdowns[' . $_ . ']} '
    . '*' . ($_ + 1) . '.* '
    . $questions[$_]
} 0 .. $#questions);

# Build right column HTML
my $right_html = join("\n\n", map {
  '*' . chr(65 + $_) . '.* '
    . $answers[$shuffle[$_]]
} 0 .. $#answers);

# Wrap with MODES because wrapper tags are in eval block
my $columns = MODES(HTML =&gt; "&lt;div class='two-column'&gt;&lt;div&gt;\n$left_html\n&lt;/div&gt;&lt;div&gt;\n$right_html\n&lt;/div&gt;&lt;/div&gt;");

BEGIN_PGML
[$columns]*
END_PGML
</pre>
<p>
In this pattern, the wrapper <code>&lt;div&gt;</code> tags are built inside the Perl variable
<code>$columns</code>, so <code>MODES</code> is required to prevent PGML from escaping them.
</p>

<h3>Pattern 3: Inline MODES for wrapper segments (alternative)</h3>
<p>
You can also emit wrapper HTML segments using inline <code>MODES</code> calls between
<code>join()</code> expressions:
</p>
<pre>
BEGIN_PGML
Match each molecular scenario with its bond type.

[@ MODES(HTML =&gt; '&lt;div class="two-column"&gt;&lt;div&gt;') @]*
[@ join("\n\n", map { ... } 0 .. $#questions) @]**
[@ MODES(HTML =&gt; '&lt;/div&gt;&lt;div&gt;') @]*
[@ join("\n\n", map { ... } 0 .. $#answers) @]**
[@ MODES(HTML =&gt; '&lt;/div&gt;&lt;/div&gt;') @]*
END_PGML
</pre>
<p>
This is a middle-ground approach. Use it when you want the wrapper segments close to the content but
cannot write them directly as plain HTML in PGML.
</p>

<h3>Why MODES is needed (technical explanation)</h3>
<p>
PGML parses content once and escapes HTML tags for safety. When wrapper <code>&lt;div&gt;</code> tags
are inside Perl variables or eval blocks, PGML sees them as data to be escaped, not markup. Using
<code>MODES(HTML =&gt; ...)</code> tells PG to emit the HTML directly without escaping, but only in HTML
output mode (not TeX/PDF mode).
</p>

<p>
<strong>What happens if you forget MODES:</strong> The wrapper <code>&lt;div&gt;</code> tags appear
as literal text in the rendered problem (e.g., <code>&amp;lt;div class="two-column"&amp;gt;</code>)
or are stripped entirely, causing the layout to collapse to a single column.
</p>

<h2>CSS styling for two-column layout</h2>
<p>
Use <code>HEADER_TEXT</code> with flexbox CSS to create a responsive two-column layout. This style
works across devices and wraps to a single column on narrow screens.
</p>

<h3>Recommended flexbox style</h3>
<pre>
HEADER_TEXT(MODES(HTML =&gt; &lt;&lt;'END_STYLE'));
&lt;style&gt;
.two-column {
  display: flex;
  flex-wrap: wrap;
  gap: 2rem;
  align-items: flex-start;
  justify-content: space-evenly;
}
.two-column &gt; div {
  flex: 1 1 40%;
  min-width: 250px;
}
&lt;/style&gt;
END_STYLE
</pre>

<h3>CSS property explanations</h3>
<ul>
	<li><code>display: flex;</code> - Creates a flexible container for the two columns</li>
	<li><code>flex-wrap: wrap;</code> - Allows columns to wrap on narrow screens (mobile-friendly)</li>
	<li><code>gap: 2rem;</code> - Adds spacing between columns</li>
	<li><code>align-items: flex-start;</code> - Aligns columns to the top (not vertically centered)</li>
	<li><code>justify-content: space-evenly;</code> - Distributes horizontal space evenly</li>
	<li><code>flex: 1 1 40%;</code> - Each column takes ~40% width, can grow or shrink</li>
	<li><code>min-width: 250px;</code> - Prevents columns from becoming too narrow</li>
</ul>

<h3>Alternative alignment options</h3>
<ul>
	<li><code>align-items: center;</code> - Vertically center columns (use if heights differ significantly)</li>
	<li><code>justify-content: space-between;</code> - Push columns to edges with space between</li>
	<li><code>gap: 1rem;</code> - Reduce spacing for compact layouts</li>
</ul>

<h2>Colored labels for fixed label-to-meaning mapping</h2>
<p>
When answer labels need fixed colors by meaning (not by position), build an HTML mapping in Perl
and emit the labels with the <code>[$var]*</code> pattern (trailing asterisk required) so PGML does
not escape the <code>&lt;span&gt;</code> tags.
</p>

<h3>Building the color mapping</h3>
<pre>
# Label -&gt; HTML mapping (fixed colors by meaning)
my %answer_html = (
  'polar covalent bond' =&gt; '&lt;span style="color:#00b3b3; font-weight:700;"&gt;polar covalent bond&lt;/span&gt;',
  'non-polar covalent bond' =&gt; '&lt;span style="color:#b3b300; font-weight:700;"&gt;non-polar covalent bond&lt;/span&gt;',
  'ionic bond' =&gt; '&lt;span style="color:#009900; font-weight:700;"&gt;ionic bond&lt;/span&gt;',
  'hydrogen bond' =&gt; '&lt;span style="color:#e60000; font-weight:700;"&gt;hydrogen bond&lt;/span&gt;',
);

# Build colored HTML labels array
my @answers_html = map { $answer_html{$_} } @answers;
</pre>

<h3>Emitting colored labels in PGML</h3>
<p>
In the right-column <code>join()</code> expression, use <code>[$answers_html[$shuffle[$_]]]*</code>
with the trailing asterisk to pass through the HTML without escaping:
</p>
<pre>
[@ join(
  "\n\n",
  map {
    '*' . chr(65 + $_) . '.* '
      . '[$answers_html[$shuffle[' . $_ . ']]]*'
  } 0 .. $#answers
) @]**
</pre>

<h3>Why the trailing asterisk is required</h3>
<p>
Without the trailing <code>*</code>, PGML escapes HTML tags for safety. Using <code>[$var]*</code>
tells PGML to pass through the variable's content as raw HTML. This keeps colors tied to label
meaning even when the order is randomized. For more on this pattern, see <a href="/@go/page/555723">Text Coloring and Emphasis</a>.
</p>

<h2>Biology examples</h2>

<h3>Example 1: Chemical bond types</h3>
<p>
<strong>Scenario:</strong> Match molecular interactions with the correct bond type. Use colored
labels to distinguish bond types visually.
</p>
<pre>
my @questions = (
  'Two oxygen atoms share electrons equally',
  'Sodium transfers an electron to chlorine',
  'Partial charges on C-O bond',
  'O-H bond attracted to nearby C=O',
);

my @answers = (
  'non-polar covalent bond',
  'ionic bond',
  'polar covalent bond',
  'hydrogen bond',
);

my @shuffle = shuffle(scalar(@answers));

my %answer_html = (
  'non-polar covalent bond' =&gt; '&lt;span style="color:#b3b300; font-weight:700;"&gt;non-polar covalent bond&lt;/span&gt;',
  'ionic bond' =&gt; '&lt;span style="color:#009900; font-weight:700;"&gt;ionic bond&lt;/span&gt;',
  'polar covalent bond' =&gt; '&lt;span style="color:#00b3b3; font-weight:700;"&gt;polar covalent bond&lt;/span&gt;',
  'hydrogen bond' =&gt; '&lt;span style="color:#e60000; font-weight:700;"&gt;hydrogen bond&lt;/span&gt;',
);
my @answers_html = map { $answer_html{$_} } @answers;
</pre>
<p>
<strong>Note:</strong> Fixed colors ensure that "hydrogen bond" is always red, regardless of
randomization, helping students build consistent mental associations.
</p>

<h3>Example 2: Pathway components matched to functions</h3>
<p>
<strong>Scenario:</strong> Match glycolytic enzymes with their specific reactions in the pathway.
</p>
<pre>
my @questions = (
  'Converts glucose-6-phosphate to fructose-6-phosphate',
  'Phosphorylates fructose-6-phosphate (rate-limiting step)',
  'Splits fructose-1,6-bisphosphate into two 3-carbon sugars',
  'Converts phosphoenolpyruvate to pyruvate (ATP-generating step)',
);

my @answers = (
  'phosphoglucose isomerase',
  'phosphofructokinase-1',
  'aldolase',
  'pyruvate kinase',
);

my @choices = ('A', 'B', 'C', 'D');
my @shuffle = shuffle(scalar(@answers));

my @correct_answers = map { $choices[$shuffle[$_]] } 0 .. $#questions;
my @answer_dropdowns = map { PopUp(\@choices, $correct_answers[$_]) } 0 .. $#questions;
</pre>
<p>
<strong>Note:</strong> This example demonstrates function-to-enzyme matching without colors, focusing
on conceptual pairing for pathway memorization.
</p>

<h3>Example 3: Genetics terminology matched to definitions</h3>
<p>
<strong>Scenario:</strong> Match genetics terms with their formal definitions.
</p>
<pre>
my @questions = (
  'Observable physical characteristic',
  'Genetic makeup at a locus',
  'Alternative form of a gene',
  'Physical location of a gene on a chromosome',
);

my @answers = (
  'phenotype',
  'genotype',
  'allele',
  'locus',
);

my @choices = ('A', 'B', 'C', 'D');
my @shuffle = shuffle(scalar(@answers));

my @correct_answers = map { $choices[$shuffle[$_]] } 0 .. $#questions;
my @answer_dropdowns = map { PopUp(\@choices, $correct_answers[$_]) } 0 .. $#questions;
</pre>
<p>
<strong>Note:</strong> This is a pure definition-matching problem, ideal for introducing formal
terminology early in a genetics unit.
</p>

<h2>Common failures and fixes</h2>

<h3>Failure 1: Forgot trailing asterisk on colored labels</h3>
<p>
<strong>Symptom:</strong> Raw <code>&lt;span&gt;</code> tags appear in the rendered problem instead
of colored text.
</p>
<p>
<strong>Cause:</strong> Used <code>[$var]</code> instead of <code>[$var]*</code>, so PGML escaped
the HTML for safety.
</p>
<p>
<strong>Fix:</strong> Always use <code>[$answers_html[$shuffle[$_]]]*</code> with the trailing
asterisk to pass through HTML.
</p>
<p>
<strong>Prevention:</strong> Check all variable interpolations that contain HTML. The rule is:
<code>[$var]*</code> for HTML, <code>[$var]</code> for plain text.
</p>

<h3>Failure 2: Used MODES for everything</h3>
<p>
<strong>Symptom:</strong> Code works but is unnecessarily complex and harder to maintain.
</p>
<p>
<strong>Cause:</strong> Wrapped every HTML snippet in <code>MODES</code>, including cases where
wrapper tags could be written directly in PGML.
</p>
<p>
<strong>Fix:</strong> Use Pattern 1 (wrapper tags directly in PGML) whenever possible. Only use
<code>MODES</code> when the wrapper HTML is inside Perl eval blocks.
</p>
<p>
<strong>Prevention:</strong> Ask: "Can I write these <code>&lt;div&gt;</code> tags directly in PGML?"
If yes, do that.
</p>

<h3>Failure 3: Shuffle array index mismatch</h3>
<p>
<strong>Symptom:</strong> Wrong answers are marked correct. Dropdown selections don't map to the
displayed right-column labels.
</p>
<p>
<strong>Cause:</strong> Used <code>$shuffle[$_]</code> incorrectly in left column or right column,
breaking the mapping.
</p>
<p>
<strong>Fix:</strong> Verify that left column uses <code>$answer_dropdowns[$_]</code> (no shuffle)
and right column uses <code>$answers[$shuffle[$_]]</code> (with shuffle).
</p>
<p>
<strong>Prevention:</strong> Test with <code>problemSeed</code> values that produce different
shuffle orders. Check that correct answers remain correct.
</p>

<h3>Failure 4: PopUp choices don't match answer labels</h3>
<p>
<strong>Symptom:</strong> Dropdown shows letters that don't appear in the right column, or vice versa.
</p>
<p>
<strong>Cause:</strong> Used different <code>@choices</code> arrays for PopUp creation and
right-column labels.
</p>
<p>
<strong>Fix:</strong> Use the same <code>@choices</code> array (e.g., <code>('A', 'B', 'C', 'D')</code>)
for both PopUp widget creation and right-column label generation.
</p>
<p>
<strong>Prevention:</strong> Define <code>@choices</code> once at the top of setup and reference it
everywhere.
</p>

<h3>Failure 5: Layout collapses to single column</h3>
<p>
<strong>Symptom:</strong> Both columns stack vertically instead of appearing side-by-side.
</p>
<p>
<strong>Cause:</strong> Wrapper <code>&lt;div&gt;</code> tags were built in Perl without
<code>MODES</code>, so PGML escaped them.
</p>
<p>
<strong>Fix:</strong> Either move wrapper tags directly into PGML (Pattern 1) or wrap them with
<code>MODES(HTML =&gt; ...)</code> (Pattern 2).
</p>
<p>
<strong>Prevention:</strong> If wrapper HTML is inside a Perl variable, use <code>MODES</code>. If
it's directly in PGML, no <code>MODES</code> needed.
</p>

<h2>Creating matching banks with YAML</h2>
<p>
Instead of writing each matching problem by hand, you can define a bank of matching pairs in a YAML
file and use a generator script to produce PGML files automatically. This workflow separates content
authoring from code, making it easier for instructors to contribute questions without editing Perl.
</p>

<h3>File naming convention</h3>
<p>
Use filenames that are readable to instructors and map naturally to course chapters. Follow the
pattern: topic prefix + plain-English descriptor.
</p>
<ul>
	<li><code>enzymes_basics.yml</code> -- enzyme classes matched to reaction types</li>
	<li><code>senses_receptor_types.yml</code> -- receptor types matched to sensory modalities</li>
	<li><code>metabolism_pathway_components.yml</code> -- pathway enzymes matched to functions</li>
</ul>
<p>
Avoid deep jargon in filenames (keep jargon inside the YAML content). Future-you should know what
the bank covers without opening the file.
</p>

<h3>YAML file structure</h3>
<p>
Every YAML bank requires four top-level keys that describe what students are matching:
</p>
<table class="mt-responsive-table">
	<caption>YAML file structure: key, purpose, and example.</caption>
<colgroup><col /><col /><col /></colgroup>
<thead>
<tr>
	<th data-th="Key">Key</th>
	<th data-th="Purpose">Purpose</th>
	<th data-th="Example">Example</th>
</tr>
</thead>
<tbody>
<tr>
	<td data-th="Key"><code>key description</code></td>
	<td data-th="Purpose">Singular label for the left column</td>
	<td data-th="Example"><code>enzyme class</code></td>
</tr>
<tr>
	<td data-th="Key"><code>keys description</code></td>
	<td data-th="Purpose">Plural label for the left column</td>
	<td data-th="Example"><code>enzyme classes</code></td>
</tr>
<tr>
	<td data-th="Key"><code>value description</code></td>
	<td data-th="Purpose">Singular label for the right column</td>
	<td data-th="Example"><code>reaction type</code></td>
</tr>
<tr>
	<td data-th="Key"><code>values description</code></td>
	<td data-th="Purpose">Plural label for the right column</td>
	<td data-th="Example"><code>reaction types</code></td>
</tr>
</tbody>
</table>
<p>
The fifth required key is <code>matching pairs</code>, which holds the actual content (see next section).
</p>

<h3>Matching pairs format</h3>
<p>
Under <code>matching pairs</code>, each key maps to a list of one or more values. Each key is a
left-column concept; each value is a right-column definition or function.
</p>
<pre>
matching pairs:
  Kinase:
    - Adds a phosphate group to a substrate (phosphorylation)
    - Transfers a phosphate group to a molecule
  Phosphatase:
    - Removes a phosphate group from a substrate (dephosphorylation)
    - Catalyzes phosphate removal from a molecule
</pre>
<p>
Each key must map to a YAML list, even if there is only one value. For each generated question, the
generator picks one value per key at random.
</p>

<h3>Same concept, different phrasing</h3>
<p>
The most important quality rule: put synonyms and equivalent statements under one key as multiple
values. Do not split a single concept across multiple keys (that turns synonyms into trick questions).
</p>
<p>
This makes banks feel fresh without changing what you are assessing. Students see one wording per
key in any single question, but across different generated questions the bank naturally rotates
through alternate wordings.
</p>
<pre>
matching pairs:
  Protease:
    - Breaks peptide bonds in proteins
    - Hydrolyzes peptide bonds
  Ligase:
    - Joins two molecules by forming a new bond (often using ATP)
    - Catalyzes bond formation to link molecules
</pre>

<h3>Excluding confusable pairs</h3>
<p>
If two keys are too similar (or their values are too easy to mix up), use <code>exclude pairs</code>
so they never appear together in the same question:
</p>
<pre>
exclude pairs:
  - [Coenzyme, Cofactor]
  - [competitive inhibitor, non-competitive inhibitor]
</pre>
<p>
Use <code>exclude pairs</code> sparingly, only for classic confusions where students can reasonably
know both terms yet still mix them up under time pressure. Do not exclude pairs just because two
terms are related -- that can remove the learning objective.
</p>

<h3>Replacement rules for formatting and color</h3>
<p>
The <code>replacement_rules</code> key defines simple search-and-replace substitutions applied after
question text is constructed. This is commonly used for highlighting phrases with color or ensuring
consistent typography.
</p>
<pre>
replacement_rules:
  releases&amp;nbsp;energy: "&lt;span style='color: #e60000;'&gt;releases&amp;nbsp;energy&lt;/span&gt;"
</pre>
<p>
Colors are assigned deterministically: the same prompt set gets the same colors on every run.
If any prompt already contains HTML color markup, automatic coloring is disabled for the
entire question so author-chosen colors are preserved.
</p>

<h3>Optional metadata keys</h3>
<p>
The generators ignore unknown top-level keys, so you can add author-facing metadata for
long-term maintenance:
</p>
<ul>
	<li><code>topic</code> -- short label (e.g., <code>phototransduction</code>)</li>
	<li><code>learning_objective</code> -- one sentence (e.g., <code>Trace the cGMP pathway in rods</code>)</li>
	<li><code>source</code> -- textbook or chapter reference</li>
	<li><code>items to match per question</code> -- how many pairs appear per question (default 5)</li>
</ul>

<h2>Generating PGML files from YAML</h2>
<p>
The <code>yaml_match_to_pgml.py</code> script reads a YAML bank and produces matching-problem PGML
files. The generated files follow the same PopUp widget and <code>MODES</code> wrapper patterns
described earlier in this chapter.
</p>
<h4>What the generator does</h4>
<ul>
	<li>Reads the YAML matching pairs and descriptions</li>
	<li>Selects one value per key at random (rotating through phrasings across runs)</li>
	<li>Applies replacement rules for color and formatting</li>
	<li>Unescapes HTML entities (named and numeric) into Unicode for rendering without MathJax</li>
	<li>Converts <code>&lt;sub&gt;</code>/<code>&lt;sup&gt;</code> tags into Unicode subscripts/superscripts</li>
	<li>Outputs PGML files using the two-column flexbox layout with PopUp widgets</li>
</ul>
<p>
The default output uses inline HTML spans for replacement-rule colors. Use <code>--no-color</code>
to disable styling.
</p>

<h2>Quality checks for matching banks</h2>
<p>
Before shipping a new matching set, run through these checks:
</p>
<table class="mt-responsive-table">
	<caption>Quality checks for matching banks: check and what to look for.</caption>
<colgroup><col /><col /></colgroup>
<thead>
<tr>
	<th data-th="Check">Check</th>
	<th data-th="What to look for">What to look for</th>
</tr>
</thead>
<tbody>
<tr>
	<td data-th="Check">Single learning objective per key</td>
	<td data-th="What to look for">Each key should test one concept, not a bundle of related facts</td>
</tr>
<tr>
	<td data-th="Check">Parallel grammar</td>
	<td data-th="What to look for">All values should use the same grammatical form (all noun phrases, or all full sentences)</td>
</tr>
<tr>
	<td data-th="Check">Similar value length</td>
	<td data-th="What to look for">If one answer is much longer than others, students use length as a hint</td>
</tr>
<tr>
	<td data-th="Check">No keyword cues</td>
	<td data-th="What to look for">If a prompt contains a distinctive word, do not repeat it in the matching value</td>
</tr>
<tr>
	<td data-th="Check">Distinct values across keys</td>
	<td data-th="What to look for">If multiple keys could match the same value text, students are guessing</td>
</tr>
<tr>
	<td data-th="Check">Accessibility</td>
	<td data-th="What to look for">Do not rely on color alone to convey meaning; use color as an accent</td>
</tr>
</tbody>
</table>

<h2>Difficulty control</h2>
<p>
Adjust the difficulty of matching questions by changing the number of items and the phrasing style:
</p>
<ul>
	<li><strong>Easier:</strong> Use direct definitions and unique vocabulary. Set
	<code>items to match per question: 3</code> or <code>4</code> for fewer items per question.</li>
	<li><strong>Harder:</strong> Use mechanism or consequence phrasing instead of definitions. Include
	more similar terms in the bank, then use <code>exclude pairs</code> for the worst confusions.</li>
</ul>

<h2>Copy/paste YAML example: enzyme classes</h2>
<p>
This is a complete, working YAML file for a matching bank. Copy it as a starting point for new banks.
</p>
<pre>
#YAML file for Matching Questions
topic: enzymes_basics
learning_objective: Match enzyme classes to what they do.

items to match per question: 5

key description: enzyme class
keys description: enzyme classes

value description: reaction type
values description: reaction types

matching pairs:
  Kinase:
    - Adds a phosphate group to a substrate (phosphorylation)
    - Transfers a phosphate group to a molecule
  Phosphatase:
    - Removes a phosphate group from a substrate (dephosphorylation)
    - Catalyzes phosphate removal from a molecule
  Protease:
    - Breaks peptide bonds in proteins
    - Hydrolyzes peptide bonds
  Ligase:
    - Joins two molecules by forming a new bond (often using ATP)
    - Catalyzes bond formation to link molecules
  Isomerase:
    - Rearranges atoms within a molecule to form an isomer
    - Converts a molecule into its isomer
</pre>
<p>
Each enzyme class key has two phrasing variants. The generator picks one wording per question, so
students see different phrasings across attempts while always being assessed on the same concept.
</p>

<h2>Complete working example</h2>
<p>
<strong>Organelle function matching</strong> -- A full problem using PopUp dropdowns
to match organelles with their primary functions.
</p>
<pre>
## TITLE('Match organelles to functions')
## DESCRIPTION
## Match each organelle with its primary function using
## PopUp dropdown widgets.
## ENDDESCRIPTION
## KEYWORDS('organelles','matching','PopUp','cell biology')
## DBsubject('Cell Biology')
## DBchapter('Organelles')
## DBsection('Function')
## Date('2026-02-15')
## Author('Author name')
## Institution('Institution name')

DOCUMENT();
loadMacros(
	"PGstandard.pl",
	"PGML.pl",
	"parserPopUp.pl",
	"PGcourse.pl",
);

@functions = ('ATP production', 'Protein sorting',
	'Intracellular digestion', 'Lipid synthesis');

$popup1 = PopUp(['?', @functions], 'ATP production');
$popup2 = PopUp(['?', @functions], 'Protein sorting');
$popup3 = PopUp(['?', @functions], 'Intracellular digestion');
$popup4 = PopUp(['?', @functions], 'Lipid synthesis');

BEGIN_PGML
Match each organelle with its primary function.

1. Mitochondrion [_]{$popup1}

2. Golgi apparatus [_]{$popup2}

3. Lysosome [_]{$popup3}

4. Smooth ER [_]{$popup4}
END_PGML

ENDDOCUMENT();
</pre>

<h2>Apply it today</h2>
<ul>
	<li>Write wrapper <code>&lt;div&gt;</code> tags directly in PGML whenever possible (Pattern 1).</li>
	<li>Use <code>MODES(HTML =&gt; ...)</code> only for wrapper HTML built inside eval blocks (Pattern 2).</li>
	<li>Always use <code>[$var]*</code> (trailing asterisk) for HTML variables to prevent escaping.</li>
	<li>Define <code>@choices</code> once and use it for both PopUp widgets and right-column labels.</li>
	<li>Test with multiple <code>problemSeed</code> values to verify shuffle mapping works correctly.</li>
	<li>Use 4-8 pairs for optimal cognitive load and assessment effectiveness.</li>
	<li>For YAML-based banks, define 8-20 keys with 2-4 phrasing variants each.</li>
	<li>Run quality checks for parallel grammar, similar value length, and no keyword cues.</li>
	<li>For more on colored emphasis, see <a href="/@go/page/555723">Text Coloring and Emphasis</a>. For statement-based questions, see <a href="/@go/page/555726">Randomized MC True and False Statements</a>.</li>
</ul>
